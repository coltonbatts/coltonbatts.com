---
import type { ArtSlotConfig } from '../content/art-manifest';
import { existsSync } from 'node:fs';
import { resolve } from 'node:path';
import ArtPlate from './ArtPlate.astro';

interface Props {
	slot?: ArtSlotConfig;
	fallbackLabel?: string;
	class?: string;
	caption?: string;
}

const {
	slot,
	fallbackLabel = 'Artwork slot',
	class: className = '',
	caption,
} = Astro.props;

const hasAsset = Boolean(
	slot?.src &&
		(/^https?:\/\//.test(slot.src) ||
			existsSync(resolve(process.cwd(), 'public', slot.src.replace(/^\//, '')))),
);
const isRenderable = Boolean(slot?.enabled && hasAsset);
const resolvedCaption = caption ?? slot?.caption;
const loadingValue = slot?.priority ? 'eager' : 'lazy';
const fetchPriority = slot?.priority ? 'high' : undefined;
const aspectRatio = slot?.aspect ? slot.aspect.replace(':', ' / ') : '16 / 9';
const plateClass = ['art-slot', 'art-reveal', className].filter(Boolean).join(' ');
---

<ArtPlate caption={resolvedCaption} class={plateClass}>
	<div class="art-slot__frame" style={`--slot-aspect: ${aspectRatio};`}>
		{isRenderable ? (
			slot.type === 'image' ? (
				<img
					src={slot.src}
					alt={slot.alt}
					loading={loadingValue}
					decoding="async"
					fetchpriority={fetchPriority}
					class="art-slot__media"
				/>
			) : slot.type === 'video' ? (
				<video
					src={slot.src}
					class="art-slot__media"
					autoplay
					loop
					muted
					playsinline
					controls={false}
					aria-label={slot.alt}
				></video>
				) : (
					<div class="art-slot__rive" data-rive-src={slot.src} data-rive-alt={slot.alt}>
						<canvas class="art-slot__rive-canvas" aria-hidden="true"></canvas>
						<span class="art-slot__rive-label">{slot.alt}</span>
					</div>
				)
			) : (
				<div class="art-slot__empty" aria-hidden="true">
					<span>{fallbackLabel}</span>
			</div>
		)}
		</div>
	</ArtPlate>

<script is:inline>
	const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
	if (!prefersReducedMotion) {
		const riveNodes = document.querySelectorAll('.art-slot__rive[data-rive-src]');
		if (riveNodes.length > 0) {
			import('https://unpkg.com/@rive-app/canvas@2.31.2?module')
				.then(({ Rive, Fit, Alignment }) => {
					riveNodes.forEach((node) => {
						const src = node.getAttribute('data-rive-src');
						const alt = node.getAttribute('data-rive-alt') || 'Motion artwork';
						const canvas = node.querySelector('.art-slot__rive-canvas');
						if (!src || !canvas) return;

						new Rive({
							src,
							canvas,
							autoplay: true,
							fit: Fit.Cover,
							alignment: Alignment.Center,
						});

						canvas.setAttribute('role', 'img');
						canvas.setAttribute('aria-label', alt);
						node.classList.add('art-slot__rive--loaded');
					});
				})
				.catch(() => {
					// Keep monochrome fallback label when runtime is unavailable.
				});
		}
	}
</script>
