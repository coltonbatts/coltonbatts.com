---
import BaseLayout from '../../layouts/BaseLayout.astro';
import fs from 'node:fs';
import path from 'node:path';

export function getStaticPaths() {
	const riveDir = path.join(process.cwd(), 'public', 'rive');
	if (!fs.existsSync(riveDir)) return [];

	function walk(dir: string, base: string): string[] {
		const entries = fs.readdirSync(dir, { withFileTypes: true });
		let files: string[] = [];
		for (const entry of entries) {
			const res = path.resolve(dir, entry.name);
			if (entry.isDirectory()) {
				files = [...files, ...walk(res, base)];
			} else if (entry.name.endsWith('.riv')) {
				files.push(path.relative(base, res).replace('.riv', ''));
			}
		}
		return files;
	}

	const paths = walk(riveDir, riveDir);
	return paths.map((p) => ({
		params: { path: p },
	}));
}

const { path: assetPath } = Astro.params;
const src = `/rive/${assetPath}.riv`;
const name = path.basename(assetPath!);

// Load metadata
const riveDir = path.join(process.cwd(), 'public', 'rive');
const fullPath = path.join(riveDir, `${assetPath}.json`);
let metadata: any = null;
if (fs.existsSync(fullPath)) {
	try {
		metadata = JSON.parse(fs.readFileSync(fullPath, 'utf8'));
	} catch (e) {
		console.error(`Failed to parse metadata for ${assetPath}`);
	}
}
---

<BaseLayout title={`Lab: ${assetPath}`}>
	<div class="max-w-4xl mx-auto px-6 py-12">
		<div class="flex items-center gap-4 mb-6">
			<a href="/lab" class="text-sm hover:underline">← Lab</a>
			<h1 class="text-2xl font-bold">{name}.riv</h1>
			{metadata?.description && <p class="text-gray-500 text-sm italic">{metadata.description}</p>}
		</div>

		{metadata?.tags && (
			<div class="flex flex-wrap gap-2 mb-6">
				{metadata.tags.map((tag: string) => (
					<span class="px-2 py-0.5 bg-gray-100 border border-gray-200 text-[10px] font-mono text-gray-500 rounded-sm">
						#{tag}
					</span>
				))}
				{metadata.source && (
					<a 
						href={metadata.source} 
						target="_blank" 
						rel="noopener noreferrer"
						class="px-2 py-0.5 border border-black text-[10px] font-mono hover:bg-black hover:text-white transition-colors rounded-sm"
					>
						Source ↗
					</a>
				)}
			</div>
		)}

		<!-- Rive viewport -->
		<div
			id="rive-viewport"
			data-src={src}
			data-file={assetPath}
			class="border border-black bg-gray-50 aspect-square max-h-[480px] w-full max-w-[480px] relative"
		>
		</div>

		<!-- State machine selector -->
		<div class="mt-6 mb-4">
			<div id="sm-container" class="flex flex-col gap-2">
				<div class="flex items-center gap-2">
					<label for="sm-select" class="text-sm font-semibold">State Machine</label>
					<select
						id="sm-select"
						class="border border-black px-2 py-1 text-sm font-mono flex-1 max-w-xs bg-white outline-none"
					>
						<option value="">Loading...</option>
					</select>
				</div>
			</div>
		</div>

		<!-- Controls panel (populated by script) -->
		<div id="rive-controls" class="border border-black divide-y divide-gray-200 empty:hidden">
		</div>

		<!-- Status messages -->
		<div id="rive-status" class="mt-4 text-sm text-gray-500 empty:hidden"></div>

		<!-- Snippet output -->
		<div class="mt-6">
			<div class="flex items-center justify-between mb-2">
				<p class="text-sm font-semibold">Component Snippet</p>
				<button
					id="copy-snippet"
					class="text-xs border border-black px-2 py-1 hover:bg-gray-50 transition-colors"
				>
					Copy
				</button>
			</div>
			<pre
				id="rive-snippet"
				class="bg-gray-50 border border-gray-200 p-4 text-sm font-mono overflow-x-auto whitespace-pre"
			></pre>
		</div>
	</div>

	<script type="module">
		const viewport = document.getElementById('rive-viewport');
		const controlsEl = document.getElementById('rive-controls');
		const statusEl = document.getElementById('rive-status');
		const snippetEl = document.getElementById('rive-snippet');
		const smSelect = document.getElementById('sm-select');
		const copyBtn = document.getElementById('copy-snippet');

		if (!viewport || !controlsEl || !snippetEl) {
			throw new Error('Missing required DOM elements');
		}

		const src = viewport.dataset.src;
		const fileName = viewport.dataset.file;

		// Read state machine name from URL or default
		const params = new URLSearchParams(window.location.search);
		let smName = params.get('sm');

		// Track current input values for snippet generation
		let currentInputs = {};
		let riveInstance = null;

		// Create a persistent canvas
		const canvas = document.createElement('canvas');
		canvas.setAttribute('aria-hidden', 'true');
		canvas.style.width = '100%';
		canvas.style.height = '100%';
		canvas.style.display = 'block';
		viewport.appendChild(canvas);

		async function init(stateMachineName) {
			// Cleanup previous instance
			if (riveInstance) {
				riveInstance.cleanup();
				riveInstance = null;
			}

			controlsEl.innerHTML = '';
			statusEl.textContent = '';
			currentInputs = {};
			smName = stateMachineName;

			const { Rive, StateMachineInputType } = await import(
				'@rive-app/canvas'
			);

			riveInstance = new Rive({
				src,
				canvas,
				autoplay: true,
				stateMachines: smName,
				onLoad: () => {
					// Discover state machines if we haven't yet or if they changed
					const machineNames = riveInstance.stateMachineNames;
					if (smSelect instanceof HTMLSelectElement) {
						smSelect.innerHTML = '';
						machineNames.forEach((name) => {
							const opt = document.createElement('option');
							opt.value = name;
							opt.textContent = name;
							opt.selected = name === smName;
							smSelect.appendChild(opt);
						});

						// If no smName was provided or it's invalid, use the first one
						if (!smName && machineNames.length > 0) {
							smName = machineNames[0];
							smSelect.value = smName;
							// Re-init with the actual first state machine to get inputs
							riveInstance.cleanup();
							init(smName);
							return;
						}
					}

					if (smName) {
						const inputs = riveInstance.stateMachineInputs(smName);
						if (inputs && inputs.length > 0) {
							statusEl.textContent = `${inputs.length} input${inputs.length !== 1 ? 's' : ''} on "${smName}"`;
							buildControls(inputs, StateMachineInputType);
						} else {
							statusEl.textContent = `No inputs found for "${smName}".`;
						}
					}

					updateSnippet();
				},
				onLoadError: () => {
					statusEl.textContent = `Failed to load ${src}`;
				},
			});
		}

		function buildControls(inputs, InputType) {
			inputs.forEach((input) => {
				const row = document.createElement('div');
				row.className =
					'flex items-center justify-between px-4 py-3';

				const label = document.createElement('span');
				label.className = 'text-sm font-mono';
				label.textContent = input.name;
				row.appendChild(label);

				if (input.type === InputType.Boolean) {
					currentInputs[input.name] = !!input.value;

					const toggle = document.createElement('button');
					let val = !!input.value;

					function renderToggle() {
						toggle.textContent = val ? 'true' : 'false';
						toggle.className = val
							? 'px-3 py-1 border border-black text-xs font-semibold bg-black text-white'
							: 'px-3 py-1 border border-black text-xs font-semibold bg-white text-black';
					}
					renderToggle();

					toggle.addEventListener('click', () => {
						val = !val;
						input.value = val;
						currentInputs[input.name] = val;
						renderToggle();
						updateSnippet();
					});

					row.appendChild(toggle);
				} else if (input.type === InputType.Number) {
					const val = input.value ?? 0;
					currentInputs[input.name] = val;

					const wrapper = document.createElement('div');
					wrapper.className = 'flex items-center gap-2';

					const slider = document.createElement('input');
					slider.type = 'range';
					slider.min = '0';
					slider.max = '100';
					slider.step = '1';
					slider.value = String(val);
					slider.className = 'w-32 accent-black';

					const display = document.createElement('span');
					display.className = 'text-xs font-mono w-8 text-right';
					display.textContent = String(val);

					slider.addEventListener('input', () => {
						const num = Number(slider.value);
						input.value = num;
						currentInputs[input.name] = num;
						display.textContent = String(num);
						updateSnippet();
					});

					wrapper.appendChild(slider);
					wrapper.appendChild(display);
					row.appendChild(wrapper);
				} else if (input.type === InputType.Trigger) {
					const btn = document.createElement('button');
					btn.className =
						'px-3 py-1 border border-black text-xs font-semibold hover:bg-gray-50 active:bg-black active:text-white transition-all duration-75';
					btn.textContent = 'Fire';
					btn.addEventListener('click', () => {
						input.fire();
						// Visual feedback
						btn.classList.add('bg-black', 'text-white');
						setTimeout(() => {
							btn.classList.remove('bg-black', 'text-white');
						}, 100);
					});
					row.appendChild(btn);
					// Triggers don't persist in snippet inputs
				}

				controlsEl.appendChild(row);
			});
		}

		function updateSnippet() {
			const hasInputs = Object.keys(currentInputs).length > 0;
			// Build tag name indirectly so rive-lint doesn't match this template
			const tag = 'Rive';
			const lines = [
				`<${tag}`,
				`  src="/rive/${fileName}.riv"`,
				`  stateMachine="${smName}"`,
				`  mode="play-when-visible"`,
			];
			if (hasInputs) {
				const formatted = JSON.stringify(currentInputs, null, 2)
					.split('\n')
					.map((line, i) => (i === 0 ? line : '    ' + line))
					.join('\n');
				lines.push(`  inputs={${formatted}}`);
			}
			lines.push('/>');
			snippetEl.textContent = lines.join('\n');
		}

		// Copy to clipboard
		if (copyBtn) {
			copyBtn.addEventListener('click', () => {
				const code = snippetEl.textContent || '';
				navigator.clipboard.writeText(code).then(() => {
					copyBtn.textContent = 'Copied';
					setTimeout(() => {
						copyBtn.textContent = 'Copy';
					}, 1500);
				});
			});
		}

		// State machine dropdown
		if (smSelect instanceof HTMLSelectElement) {
			smSelect.addEventListener('change', () => {
				const newName = smSelect.value;
				if (!newName) return;
				init(newName);
				const url = new URL(window.location.href);
				url.searchParams.set('sm', newName);
				history.replaceState(null, '', url.toString());
			});
		}

		// Cleanup on Astro navigation
		document.addEventListener('astro:before-preparation', () => {
			if (riveInstance) {
				riveInstance.cleanup();
				riveInstance = null;
			}
		});

		// Go
		init(smName);
	</script>
</BaseLayout>
